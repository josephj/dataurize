#!/usr/bin/php
<?php
/**
 * Command line interface for converting CSS file with background images into MHTML & DataURI using base64 encoding.
 * So all separate HTTP requests for individual images will become only one request.
 *
 * @author Joseph Chiang <josephj6802@gmail.com>
 * @package dataurize
 *
 * ./dataurize <input> <base> [--output]
 */


function print_usage($path)
{
    echo "Usage: {$path} <input> <base> [options]\n" .
         "\n";
    echo "    -o\n";
    echo "    --output=<output>    Assign an output file. By default it overwrites your original file.\n";
    echo "    --print              Print output directly instead of generating or overwriting a file.\n".
         "                         By default, this option is disabled. \n";
    echo "    --separate=<output>  Separate MHTML to a single file. By default, this option is disabled. \n";
    echo "    --no-mhtml           Don't enable MHTML. Use this option if you don't want to use MHTML for legend IE.\n".
         "                         It however doesn't hurt browser compatibility by adding *background-image(<Original Image Path>).\n".
         "                         By default, this option is disabled.\n";
    echo "    --size-limit=<bytes> It might still damage website performance if you transform an image with large file size.\n".
         "                         The default file size is 1024 bytes.\n";
    echo "    -h\n";
    echo "    --help               Show this help.\n" .
         "\n";
    echo "Sample: {$path} foo.css http://bar.com/ --output=foo2.css\n\n";
    exit;
}

function handle_exception($ex)
{
    die("Error: ".$ex->getMessage()."\n");
}

set_exception_handler("handle_exception");

// Constants.
define("SEPARATOR", "_MY_BOUNDARY_SEPARATOR");

// Provide usage if user provides no or insufficeient arguments.
$path = array_shift($argv);
if ( ! count($argv) || count($argv) < 2)
{
    print_usage($path);
    exit;
}

// Check if file exists.
$input = array_shift($argv);
if ( ! file_exists($input))
{
    throw new Exception("File you provide doesn't exist. Please check again.");
}

// Define option default values.
$base = array_shift($argv);  // Base URL for relative paths in CSS content.
$num  = preg_match('/(https?:\/\/[^\s+\"\<\>]+)/i', $base);
if ( ! $num)
{
    throw new Exception("You must provide a URL which begins with 'http://' or 'https://'.");
}
if (strrpos($base, "/") !== count($base) - 1) // Always add slash at end.
{
    $base .= "/";
}

$output     = $input; // Output file.
$size_limit = 1024;   // Maximum image size.
$is_print   = FALSE;  // Only print to console instead of making or overwritting an output file.
$is_mhtml   = TRUE;   // Enable MHMTL support.
$separate   = FALSE;  // Separate MHTML to a different file. (Mixed type)

// Loops user inputs arguments.
while ($arg = array_shift($argv))
{
    // Check option format.
    $num = preg_match('/(-{1,2}([^=]+))=*([^\s]+)*/', $arg, $matches);
    if ( ! $num)
    {
        continue;
    }
    $val = (isset($matches[3]) ? $matches[3] : "");

    switch ($matches[1])
    {
    // Get output file.
    case "-o":
    case "--output":
        $output = $val;
        break;
    case "--separate":
        $separate = $val;
        break;
    case "--size-limit":
        $size_limit = intval($val);
        break;
    case "--print":
        $is_print = TRUE;
        break;
    case "--no-mhtml":
        $is_mhtml = FALSE;
        break;
    case "-h":
    case "--help":
        print_usage($path);
        exit;
        break;
    }
}

// Fetch all the background image attributes using RegExp.
$content = file_get_contents($input);
$pattern = '/background[^:]*:[^;}]*url\(([^\)]+)\)[^;}]*/';
preg_match_all($pattern, $content, $data);
$attrs   = $data[0];
$urls    = $data[1];
$uris    = array();
$mhtmls  = array();
$removes = array();

// Build temporary directory.
$tmp_path = microtime();
$tmp_path = substr(md5($tmp_path), 0, 8);
$tmp_path = "/tmp/$tmp_path/";
mkdir($tmp_path);

for ($i = 0, $j = count($attrs); $i < $j; $i++)
{
    // Make shortcut and normalize string.
    $attr = str_replace(array("\"", "'"), array("", ""), $attrs[$i]);
    $url  = str_replace(array("\"", "'"), array("", ""), $urls[$i]);

    // Ignore original DataURIs.
    if (strpos($url, "data:") === 0)
    {
        $removes[] = $i;
        continue;
    }

    // Remove heading slash.
    $url2 = (strpos($url, "/") === 0) ? substr($url, 1) : $url;

    // Get images file using cURL.
    $target = (strpos($url, "http") === 0 ? $url : $base . $url2);
    $filename = pathinfo($target);
    $filename = "{$filename["filename"]}.{$filename["extension"]}";
    $cmd = "curl $target -s > {$tmp_path}{$filename}";
    exec($cmd, $return, $error);
    if ($error)
    {
        $removes[] = $i;
        continue;
    }
    
    // Ignore image exceeds file size limit.
    if (filesize($tmp_path.$filename) > $size_limit)
    {
        $removes[] = $i;
        continue;
    }

    // Get file MIME/TYPE.
    $tempfile = $tmp_path.$filename;
    $cmd = "/usr/bin/identify -quiet -format \"%m\" $tempfile";
    exec($cmd, $return, $error);                                    
    if ($error)
    {
        $removes[] = $i;
        continue;
    }
    $type = mb_strtolower($return[0]);

    // Get encoded string.
    try
    {
        $encode = base64_encode(file_get_contents($tempfile)); 
    }
    catch (Exception $e) 
    {
        $removes[] = $i;
        continue;
    }

    // Save DataURI strings into working array.
    $mhtml_path = ($separate) ? $base . $separate : $base . basename($output);
    $uri        = str_replace($url, "\"data:image/$type;base64," . $encode . "\"", $attr);
    $url        = ($is_mhtml) ? "mhtml:{$mhtml_path}!{$i}" : $url;
    $uris[]     = $uri . ";*background-image:url($url)";
    $mhtmls[]   = "--" . SEPARATOR . "\nContent-Location:{$i}\nContent-Transfer-Encoding:base64\n\n" . $encode . "\n\n";
}

// Remove temporary directory.
$cmd = "rm -rf $tmp_path";
exec($cmd, $return, $error);

// New CSS file content.
$mhtml   = ($is_mhtml) ? "/*\nContent-Type: multipart/related; boundary=\"" . SEPARATOR . "\"\n\n" . implode($mhtmls, "") . "--".SEPARATOR."--\n*/\n" : "";
for ($i = count($removes) - 1, $j = 0; $i >= $j; $i--)
{
    array_splice($attrs, $removes[$i], 1);
}
$content = str_replace($attrs, $uris, $content);
if ($is_print)
{
    echo $mhtml . $content;
    exit;
}
if ($separate)
{
    file_put_contents($separate, $mhtml);
    file_put_contents($output, $content);
} else {
    file_put_contents($output, $mhtml . $content);
}

exit;
?>
